plugins {
  id "com.bmuschko.docker-java-application" version "2.0.2"
  id "com.bmuschko.docker-remote-api" version "2.0.2"
}

import com.bmuschko.gradle.docker.tasks.image.DockerInspectImage
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer

apply plugin: 'eclipse'

ext {
  versions = [
    dropwizard: '0.7.1',
    querydsl: '3.5.0',
    swagger_ui : '2.0.24',
  ]
  generated = "src/main/generated"
}

subprojects {
  apply plugin: 'java'
  apply plugin: 'application'
  apply plugin: 'com.bmuschko.docker-remote-api'
  apply plugin: 'com.bmuschko.docker-java-application'
  apply plugin: 'eclipse'
  group = 'earay'
  archivesBaseName = "earay-" + project.name
  sourceCompatibility = 1.7
  compileJava.options.encoding = 'UTF-8'
  repositories {
// definitely there is a bug in gradle working with mavenLocal http://forums.gradle.org/gradle/topics/gradle_fails_to_download_dependencies_if_not_present_in_mavenlocal. as mavenLocal doesn't introduce any performance benefits, comment it out in category repositories. 
//  mavenLocal()
    mavenCentral()
  }
  sourceSets {
    generated {
      java {
        srcDirs = [project.generated]
      }
    }
  }
  configurations {
    querydslapt
    querydslaptEclipse
  }
  task generateQueryDSL(type: JavaCompile, group: 'build', description: 'Generates the QueryDSL query types') {
    source = sourceSets.main.java
    classpath = configurations.compile + configurations.querydslapt
    options.compilerArgs = [
      "-proc:only",
      "-processor", "com.mysema.query.apt.jpa.JPAAnnotationProcessor"
    ]
    destinationDir = file(project.generated)
  }
  compileJava {
    dependsOn generateQueryDSL
    source project.generated
  }
  compileGeneratedJava {
    dependsOn generateQueryDSL
    options.warnings = false
    classpath += sourceSets.main.runtimeClasspath
  }
  clean {
    delete project.generated
  }
  eclipse {
    classpath {
      plusConfigurations += [ configurations.querydslapt, configurations.querydslaptEclipse ]
      noExportConfigurations += [ configurations.querydslaptEclipse ]
      defaultOutputDir = file('build/eclipse/classes')
      downloadSources = true
      downloadJavadoc = false
      file {
        whenMerged { classpath ->
          def aptPaths = classpath.entries.findAll {
            entry -> entry.path.indexOf('apt-hibernate-one-jar') > 0 }
          project.ext["aptPath"] = aptPaths.iterator().next().path
          classpath.entries.removeAll(aptPaths)
//          classpath.entries.removeAll { entry -> entry.kind == "lib" && entry.exported == false }
        }
      }
    }
  }
  eclipseJdt << {
    File f = file(".factorypath")
    f.write("<factorypath>\n\t<factorypathentry kind=\"EXTJAR\" id=\"${project.aptPath}\" enabled=\"true\" runInBatchMode=\"false\"/>\n</factorypath>")
    f = file(".settings/org.eclipse.core.resources.prefs")
    f.write("eclipse.preferences.version=1\n")
    f.append("encoding/${project.name}=UTF-8")
    f = file(".settings/org.eclipse.jdt.apt.core.prefs")
    f.write("eclipse.preferences.version=1\n")
    f.append("org.eclipse.jdt.apt.aptEnabled=true\n")
    f.append("org.eclipse.jdt.apt.genSrcDir=${project.generated}\n")
    f.append("org.eclipse.jdt.apt.processorOptions/defaultOverwrite=true\n")
    f.append("org.eclipse.jdt.apt.reconcileEnabled=true\n")
    f = file(".settings/org.eclipse.jdt.core.prefs")
    f.append("org.eclipse.jdt.core.compiler.processAnnotations=enabled")
  }
  cleanEclipse << {
    delete ".factorypath"
    delete ".settings"
  }
  dependencies {
    querydslapt "com.mysema.querydsl:querydsl-apt:${versions.querydsl}:hibernate"
    querydslaptEclipse "com.mysema.querydsl:querydsl-jpa:${versions.querydsl}:apt-hibernate-one-jar"
  }
  run {
    if (project.hasProperty('runSpec')) {
      args 'server', project.runSpec
    }
    if (project.hasProperty('args')) {
      args project.args.split('\\s+')
    }
  }
  docker {
    url = 'https://10.111.57.114:2376'
    certPath = new File(System.properties['user.home'], '.docker/machine/machines/vdocker2')
    javaApplication {
      maintainer = 'Chandler Zhang "chengz@vmware.com"'
    }
  }
  dockerCopyDistResources {
    if (project.hasProperty('runSpec')) {
      from file(project.runSpec)
    }
  }
  dockerDistTar {
    if (project.hasProperty('runSpec')) {
      addFile file(project.runSpec).name, '/earay.yml'
    }
  }
  task inspectImage(type: DockerInspectImage) {
    dependsOn dockerBuildImage
    targetImageId { dockerBuildImage.getImageId() }
  }
  task createContainer(type: DockerCreateContainer) {
    dependsOn inspectImage
    targetImageId { dockerBuildImage.getImageId() }
  }
  task startContainer(type: DockerStartContainer) {
    dependsOn createContainer
    targetContainerId { createContainer.getContainerId() }
  }
}
